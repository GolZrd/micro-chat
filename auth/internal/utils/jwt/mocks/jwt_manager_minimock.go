// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/GolZrd/micro-chat/auth/internal/utils/jwt.JWTManager -o jwt_manager_minimock.go -n JWTManagerMock -p mocks

import (
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/GolZrd/micro-chat/auth/internal/model"
	"github.com/gojuno/minimock/v3"
)

// JWTManagerMock implements mm_jwt.JWTManager
type JWTManagerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGenerateToken          func(user model.UserAuthData, secretKey string, ttl time.Duration) (s1 string, err error)
	funcGenerateTokenOrigin    string
	inspectFuncGenerateToken   func(user model.UserAuthData, secretKey string, ttl time.Duration)
	afterGenerateTokenCounter  uint64
	beforeGenerateTokenCounter uint64
	GenerateTokenMock          mJWTManagerMockGenerateToken

	funcVerifyToken          func(tokenStr string, secretKey []byte) (up1 *model.UserClaims, err error)
	funcVerifyTokenOrigin    string
	inspectFuncVerifyToken   func(tokenStr string, secretKey []byte)
	afterVerifyTokenCounter  uint64
	beforeVerifyTokenCounter uint64
	VerifyTokenMock          mJWTManagerMockVerifyToken
}

// NewJWTManagerMock returns a mock for mm_jwt.JWTManager
func NewJWTManagerMock(t minimock.Tester) *JWTManagerMock {
	m := &JWTManagerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GenerateTokenMock = mJWTManagerMockGenerateToken{mock: m}
	m.GenerateTokenMock.callArgs = []*JWTManagerMockGenerateTokenParams{}

	m.VerifyTokenMock = mJWTManagerMockVerifyToken{mock: m}
	m.VerifyTokenMock.callArgs = []*JWTManagerMockVerifyTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mJWTManagerMockGenerateToken struct {
	optional           bool
	mock               *JWTManagerMock
	defaultExpectation *JWTManagerMockGenerateTokenExpectation
	expectations       []*JWTManagerMockGenerateTokenExpectation

	callArgs []*JWTManagerMockGenerateTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JWTManagerMockGenerateTokenExpectation specifies expectation struct of the JWTManager.GenerateToken
type JWTManagerMockGenerateTokenExpectation struct {
	mock               *JWTManagerMock
	params             *JWTManagerMockGenerateTokenParams
	paramPtrs          *JWTManagerMockGenerateTokenParamPtrs
	expectationOrigins JWTManagerMockGenerateTokenExpectationOrigins
	results            *JWTManagerMockGenerateTokenResults
	returnOrigin       string
	Counter            uint64
}

// JWTManagerMockGenerateTokenParams contains parameters of the JWTManager.GenerateToken
type JWTManagerMockGenerateTokenParams struct {
	user      model.UserAuthData
	secretKey string
	ttl       time.Duration
}

// JWTManagerMockGenerateTokenParamPtrs contains pointers to parameters of the JWTManager.GenerateToken
type JWTManagerMockGenerateTokenParamPtrs struct {
	user      *model.UserAuthData
	secretKey *string
	ttl       *time.Duration
}

// JWTManagerMockGenerateTokenResults contains results of the JWTManager.GenerateToken
type JWTManagerMockGenerateTokenResults struct {
	s1  string
	err error
}

// JWTManagerMockGenerateTokenOrigins contains origins of expectations of the JWTManager.GenerateToken
type JWTManagerMockGenerateTokenExpectationOrigins struct {
	origin          string
	originUser      string
	originSecretKey string
	originTtl       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGenerateToken *mJWTManagerMockGenerateToken) Optional() *mJWTManagerMockGenerateToken {
	mmGenerateToken.optional = true
	return mmGenerateToken
}

// Expect sets up expected params for JWTManager.GenerateToken
func (mmGenerateToken *mJWTManagerMockGenerateToken) Expect(user model.UserAuthData, secretKey string, ttl time.Duration) *mJWTManagerMockGenerateToken {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &JWTManagerMockGenerateTokenExpectation{}
	}

	if mmGenerateToken.defaultExpectation.paramPtrs != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by ExpectParams functions")
	}

	mmGenerateToken.defaultExpectation.params = &JWTManagerMockGenerateTokenParams{user, secretKey, ttl}
	mmGenerateToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGenerateToken.expectations {
		if minimock.Equal(e.params, mmGenerateToken.defaultExpectation.params) {
			mmGenerateToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGenerateToken.defaultExpectation.params)
		}
	}

	return mmGenerateToken
}

// ExpectUserParam1 sets up expected param user for JWTManager.GenerateToken
func (mmGenerateToken *mJWTManagerMockGenerateToken) ExpectUserParam1(user model.UserAuthData) *mJWTManagerMockGenerateToken {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &JWTManagerMockGenerateTokenExpectation{}
	}

	if mmGenerateToken.defaultExpectation.params != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by Expect")
	}

	if mmGenerateToken.defaultExpectation.paramPtrs == nil {
		mmGenerateToken.defaultExpectation.paramPtrs = &JWTManagerMockGenerateTokenParamPtrs{}
	}
	mmGenerateToken.defaultExpectation.paramPtrs.user = &user
	mmGenerateToken.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmGenerateToken
}

// ExpectSecretKeyParam2 sets up expected param secretKey for JWTManager.GenerateToken
func (mmGenerateToken *mJWTManagerMockGenerateToken) ExpectSecretKeyParam2(secretKey string) *mJWTManagerMockGenerateToken {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &JWTManagerMockGenerateTokenExpectation{}
	}

	if mmGenerateToken.defaultExpectation.params != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by Expect")
	}

	if mmGenerateToken.defaultExpectation.paramPtrs == nil {
		mmGenerateToken.defaultExpectation.paramPtrs = &JWTManagerMockGenerateTokenParamPtrs{}
	}
	mmGenerateToken.defaultExpectation.paramPtrs.secretKey = &secretKey
	mmGenerateToken.defaultExpectation.expectationOrigins.originSecretKey = minimock.CallerInfo(1)

	return mmGenerateToken
}

// ExpectTtlParam3 sets up expected param ttl for JWTManager.GenerateToken
func (mmGenerateToken *mJWTManagerMockGenerateToken) ExpectTtlParam3(ttl time.Duration) *mJWTManagerMockGenerateToken {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &JWTManagerMockGenerateTokenExpectation{}
	}

	if mmGenerateToken.defaultExpectation.params != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by Expect")
	}

	if mmGenerateToken.defaultExpectation.paramPtrs == nil {
		mmGenerateToken.defaultExpectation.paramPtrs = &JWTManagerMockGenerateTokenParamPtrs{}
	}
	mmGenerateToken.defaultExpectation.paramPtrs.ttl = &ttl
	mmGenerateToken.defaultExpectation.expectationOrigins.originTtl = minimock.CallerInfo(1)

	return mmGenerateToken
}

// Inspect accepts an inspector function that has same arguments as the JWTManager.GenerateToken
func (mmGenerateToken *mJWTManagerMockGenerateToken) Inspect(f func(user model.UserAuthData, secretKey string, ttl time.Duration)) *mJWTManagerMockGenerateToken {
	if mmGenerateToken.mock.inspectFuncGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("Inspect function is already set for JWTManagerMock.GenerateToken")
	}

	mmGenerateToken.mock.inspectFuncGenerateToken = f

	return mmGenerateToken
}

// Return sets up results that will be returned by JWTManager.GenerateToken
func (mmGenerateToken *mJWTManagerMockGenerateToken) Return(s1 string, err error) *JWTManagerMock {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by Set")
	}

	if mmGenerateToken.defaultExpectation == nil {
		mmGenerateToken.defaultExpectation = &JWTManagerMockGenerateTokenExpectation{mock: mmGenerateToken.mock}
	}
	mmGenerateToken.defaultExpectation.results = &JWTManagerMockGenerateTokenResults{s1, err}
	mmGenerateToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGenerateToken.mock
}

// Set uses given function f to mock the JWTManager.GenerateToken method
func (mmGenerateToken *mJWTManagerMockGenerateToken) Set(f func(user model.UserAuthData, secretKey string, ttl time.Duration) (s1 string, err error)) *JWTManagerMock {
	if mmGenerateToken.defaultExpectation != nil {
		mmGenerateToken.mock.t.Fatalf("Default expectation is already set for the JWTManager.GenerateToken method")
	}

	if len(mmGenerateToken.expectations) > 0 {
		mmGenerateToken.mock.t.Fatalf("Some expectations are already set for the JWTManager.GenerateToken method")
	}

	mmGenerateToken.mock.funcGenerateToken = f
	mmGenerateToken.mock.funcGenerateTokenOrigin = minimock.CallerInfo(1)
	return mmGenerateToken.mock
}

// When sets expectation for the JWTManager.GenerateToken which will trigger the result defined by the following
// Then helper
func (mmGenerateToken *mJWTManagerMockGenerateToken) When(user model.UserAuthData, secretKey string, ttl time.Duration) *JWTManagerMockGenerateTokenExpectation {
	if mmGenerateToken.mock.funcGenerateToken != nil {
		mmGenerateToken.mock.t.Fatalf("JWTManagerMock.GenerateToken mock is already set by Set")
	}

	expectation := &JWTManagerMockGenerateTokenExpectation{
		mock:               mmGenerateToken.mock,
		params:             &JWTManagerMockGenerateTokenParams{user, secretKey, ttl},
		expectationOrigins: JWTManagerMockGenerateTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGenerateToken.expectations = append(mmGenerateToken.expectations, expectation)
	return expectation
}

// Then sets up JWTManager.GenerateToken return parameters for the expectation previously defined by the When method
func (e *JWTManagerMockGenerateTokenExpectation) Then(s1 string, err error) *JWTManagerMock {
	e.results = &JWTManagerMockGenerateTokenResults{s1, err}
	return e.mock
}

// Times sets number of times JWTManager.GenerateToken should be invoked
func (mmGenerateToken *mJWTManagerMockGenerateToken) Times(n uint64) *mJWTManagerMockGenerateToken {
	if n == 0 {
		mmGenerateToken.mock.t.Fatalf("Times of JWTManagerMock.GenerateToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGenerateToken.expectedInvocations, n)
	mmGenerateToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGenerateToken
}

func (mmGenerateToken *mJWTManagerMockGenerateToken) invocationsDone() bool {
	if len(mmGenerateToken.expectations) == 0 && mmGenerateToken.defaultExpectation == nil && mmGenerateToken.mock.funcGenerateToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGenerateToken.mock.afterGenerateTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGenerateToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GenerateToken implements mm_jwt.JWTManager
func (mmGenerateToken *JWTManagerMock) GenerateToken(user model.UserAuthData, secretKey string, ttl time.Duration) (s1 string, err error) {
	mm_atomic.AddUint64(&mmGenerateToken.beforeGenerateTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmGenerateToken.afterGenerateTokenCounter, 1)

	mmGenerateToken.t.Helper()

	if mmGenerateToken.inspectFuncGenerateToken != nil {
		mmGenerateToken.inspectFuncGenerateToken(user, secretKey, ttl)
	}

	mm_params := JWTManagerMockGenerateTokenParams{user, secretKey, ttl}

	// Record call args
	mmGenerateToken.GenerateTokenMock.mutex.Lock()
	mmGenerateToken.GenerateTokenMock.callArgs = append(mmGenerateToken.GenerateTokenMock.callArgs, &mm_params)
	mmGenerateToken.GenerateTokenMock.mutex.Unlock()

	for _, e := range mmGenerateToken.GenerateTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGenerateToken.GenerateTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGenerateToken.GenerateTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmGenerateToken.GenerateTokenMock.defaultExpectation.params
		mm_want_ptrs := mmGenerateToken.GenerateTokenMock.defaultExpectation.paramPtrs

		mm_got := JWTManagerMockGenerateTokenParams{user, secretKey, ttl}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmGenerateToken.t.Errorf("JWTManagerMock.GenerateToken got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateToken.GenerateTokenMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

			if mm_want_ptrs.secretKey != nil && !minimock.Equal(*mm_want_ptrs.secretKey, mm_got.secretKey) {
				mmGenerateToken.t.Errorf("JWTManagerMock.GenerateToken got unexpected parameter secretKey, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateToken.GenerateTokenMock.defaultExpectation.expectationOrigins.originSecretKey, *mm_want_ptrs.secretKey, mm_got.secretKey, minimock.Diff(*mm_want_ptrs.secretKey, mm_got.secretKey))
			}

			if mm_want_ptrs.ttl != nil && !minimock.Equal(*mm_want_ptrs.ttl, mm_got.ttl) {
				mmGenerateToken.t.Errorf("JWTManagerMock.GenerateToken got unexpected parameter ttl, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGenerateToken.GenerateTokenMock.defaultExpectation.expectationOrigins.originTtl, *mm_want_ptrs.ttl, mm_got.ttl, minimock.Diff(*mm_want_ptrs.ttl, mm_got.ttl))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGenerateToken.t.Errorf("JWTManagerMock.GenerateToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGenerateToken.GenerateTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGenerateToken.GenerateTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmGenerateToken.t.Fatal("No results are set for the JWTManagerMock.GenerateToken")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGenerateToken.funcGenerateToken != nil {
		return mmGenerateToken.funcGenerateToken(user, secretKey, ttl)
	}
	mmGenerateToken.t.Fatalf("Unexpected call to JWTManagerMock.GenerateToken. %v %v %v", user, secretKey, ttl)
	return
}

// GenerateTokenAfterCounter returns a count of finished JWTManagerMock.GenerateToken invocations
func (mmGenerateToken *JWTManagerMock) GenerateTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateToken.afterGenerateTokenCounter)
}

// GenerateTokenBeforeCounter returns a count of JWTManagerMock.GenerateToken invocations
func (mmGenerateToken *JWTManagerMock) GenerateTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGenerateToken.beforeGenerateTokenCounter)
}

// Calls returns a list of arguments used in each call to JWTManagerMock.GenerateToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGenerateToken *mJWTManagerMockGenerateToken) Calls() []*JWTManagerMockGenerateTokenParams {
	mmGenerateToken.mutex.RLock()

	argCopy := make([]*JWTManagerMockGenerateTokenParams, len(mmGenerateToken.callArgs))
	copy(argCopy, mmGenerateToken.callArgs)

	mmGenerateToken.mutex.RUnlock()

	return argCopy
}

// MinimockGenerateTokenDone returns true if the count of the GenerateToken invocations corresponds
// the number of defined expectations
func (m *JWTManagerMock) MinimockGenerateTokenDone() bool {
	if m.GenerateTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GenerateTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GenerateTokenMock.invocationsDone()
}

// MinimockGenerateTokenInspect logs each unmet expectation
func (m *JWTManagerMock) MinimockGenerateTokenInspect() {
	for _, e := range m.GenerateTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JWTManagerMock.GenerateToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGenerateTokenCounter := mm_atomic.LoadUint64(&m.afterGenerateTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GenerateTokenMock.defaultExpectation != nil && afterGenerateTokenCounter < 1 {
		if m.GenerateTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JWTManagerMock.GenerateToken at\n%s", m.GenerateTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JWTManagerMock.GenerateToken at\n%s with params: %#v", m.GenerateTokenMock.defaultExpectation.expectationOrigins.origin, *m.GenerateTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGenerateToken != nil && afterGenerateTokenCounter < 1 {
		m.t.Errorf("Expected call to JWTManagerMock.GenerateToken at\n%s", m.funcGenerateTokenOrigin)
	}

	if !m.GenerateTokenMock.invocationsDone() && afterGenerateTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to JWTManagerMock.GenerateToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GenerateTokenMock.expectedInvocations), m.GenerateTokenMock.expectedInvocationsOrigin, afterGenerateTokenCounter)
	}
}

type mJWTManagerMockVerifyToken struct {
	optional           bool
	mock               *JWTManagerMock
	defaultExpectation *JWTManagerMockVerifyTokenExpectation
	expectations       []*JWTManagerMockVerifyTokenExpectation

	callArgs []*JWTManagerMockVerifyTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// JWTManagerMockVerifyTokenExpectation specifies expectation struct of the JWTManager.VerifyToken
type JWTManagerMockVerifyTokenExpectation struct {
	mock               *JWTManagerMock
	params             *JWTManagerMockVerifyTokenParams
	paramPtrs          *JWTManagerMockVerifyTokenParamPtrs
	expectationOrigins JWTManagerMockVerifyTokenExpectationOrigins
	results            *JWTManagerMockVerifyTokenResults
	returnOrigin       string
	Counter            uint64
}

// JWTManagerMockVerifyTokenParams contains parameters of the JWTManager.VerifyToken
type JWTManagerMockVerifyTokenParams struct {
	tokenStr  string
	secretKey []byte
}

// JWTManagerMockVerifyTokenParamPtrs contains pointers to parameters of the JWTManager.VerifyToken
type JWTManagerMockVerifyTokenParamPtrs struct {
	tokenStr  *string
	secretKey *[]byte
}

// JWTManagerMockVerifyTokenResults contains results of the JWTManager.VerifyToken
type JWTManagerMockVerifyTokenResults struct {
	up1 *model.UserClaims
	err error
}

// JWTManagerMockVerifyTokenOrigins contains origins of expectations of the JWTManager.VerifyToken
type JWTManagerMockVerifyTokenExpectationOrigins struct {
	origin          string
	originTokenStr  string
	originSecretKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmVerifyToken *mJWTManagerMockVerifyToken) Optional() *mJWTManagerMockVerifyToken {
	mmVerifyToken.optional = true
	return mmVerifyToken
}

// Expect sets up expected params for JWTManager.VerifyToken
func (mmVerifyToken *mJWTManagerMockVerifyToken) Expect(tokenStr string, secretKey []byte) *mJWTManagerMockVerifyToken {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("JWTManagerMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &JWTManagerMockVerifyTokenExpectation{}
	}

	if mmVerifyToken.defaultExpectation.paramPtrs != nil {
		mmVerifyToken.mock.t.Fatalf("JWTManagerMock.VerifyToken mock is already set by ExpectParams functions")
	}

	mmVerifyToken.defaultExpectation.params = &JWTManagerMockVerifyTokenParams{tokenStr, secretKey}
	mmVerifyToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmVerifyToken.expectations {
		if minimock.Equal(e.params, mmVerifyToken.defaultExpectation.params) {
			mmVerifyToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmVerifyToken.defaultExpectation.params)
		}
	}

	return mmVerifyToken
}

// ExpectTokenStrParam1 sets up expected param tokenStr for JWTManager.VerifyToken
func (mmVerifyToken *mJWTManagerMockVerifyToken) ExpectTokenStrParam1(tokenStr string) *mJWTManagerMockVerifyToken {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("JWTManagerMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &JWTManagerMockVerifyTokenExpectation{}
	}

	if mmVerifyToken.defaultExpectation.params != nil {
		mmVerifyToken.mock.t.Fatalf("JWTManagerMock.VerifyToken mock is already set by Expect")
	}

	if mmVerifyToken.defaultExpectation.paramPtrs == nil {
		mmVerifyToken.defaultExpectation.paramPtrs = &JWTManagerMockVerifyTokenParamPtrs{}
	}
	mmVerifyToken.defaultExpectation.paramPtrs.tokenStr = &tokenStr
	mmVerifyToken.defaultExpectation.expectationOrigins.originTokenStr = minimock.CallerInfo(1)

	return mmVerifyToken
}

// ExpectSecretKeyParam2 sets up expected param secretKey for JWTManager.VerifyToken
func (mmVerifyToken *mJWTManagerMockVerifyToken) ExpectSecretKeyParam2(secretKey []byte) *mJWTManagerMockVerifyToken {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("JWTManagerMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &JWTManagerMockVerifyTokenExpectation{}
	}

	if mmVerifyToken.defaultExpectation.params != nil {
		mmVerifyToken.mock.t.Fatalf("JWTManagerMock.VerifyToken mock is already set by Expect")
	}

	if mmVerifyToken.defaultExpectation.paramPtrs == nil {
		mmVerifyToken.defaultExpectation.paramPtrs = &JWTManagerMockVerifyTokenParamPtrs{}
	}
	mmVerifyToken.defaultExpectation.paramPtrs.secretKey = &secretKey
	mmVerifyToken.defaultExpectation.expectationOrigins.originSecretKey = minimock.CallerInfo(1)

	return mmVerifyToken
}

// Inspect accepts an inspector function that has same arguments as the JWTManager.VerifyToken
func (mmVerifyToken *mJWTManagerMockVerifyToken) Inspect(f func(tokenStr string, secretKey []byte)) *mJWTManagerMockVerifyToken {
	if mmVerifyToken.mock.inspectFuncVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("Inspect function is already set for JWTManagerMock.VerifyToken")
	}

	mmVerifyToken.mock.inspectFuncVerifyToken = f

	return mmVerifyToken
}

// Return sets up results that will be returned by JWTManager.VerifyToken
func (mmVerifyToken *mJWTManagerMockVerifyToken) Return(up1 *model.UserClaims, err error) *JWTManagerMock {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("JWTManagerMock.VerifyToken mock is already set by Set")
	}

	if mmVerifyToken.defaultExpectation == nil {
		mmVerifyToken.defaultExpectation = &JWTManagerMockVerifyTokenExpectation{mock: mmVerifyToken.mock}
	}
	mmVerifyToken.defaultExpectation.results = &JWTManagerMockVerifyTokenResults{up1, err}
	mmVerifyToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmVerifyToken.mock
}

// Set uses given function f to mock the JWTManager.VerifyToken method
func (mmVerifyToken *mJWTManagerMockVerifyToken) Set(f func(tokenStr string, secretKey []byte) (up1 *model.UserClaims, err error)) *JWTManagerMock {
	if mmVerifyToken.defaultExpectation != nil {
		mmVerifyToken.mock.t.Fatalf("Default expectation is already set for the JWTManager.VerifyToken method")
	}

	if len(mmVerifyToken.expectations) > 0 {
		mmVerifyToken.mock.t.Fatalf("Some expectations are already set for the JWTManager.VerifyToken method")
	}

	mmVerifyToken.mock.funcVerifyToken = f
	mmVerifyToken.mock.funcVerifyTokenOrigin = minimock.CallerInfo(1)
	return mmVerifyToken.mock
}

// When sets expectation for the JWTManager.VerifyToken which will trigger the result defined by the following
// Then helper
func (mmVerifyToken *mJWTManagerMockVerifyToken) When(tokenStr string, secretKey []byte) *JWTManagerMockVerifyTokenExpectation {
	if mmVerifyToken.mock.funcVerifyToken != nil {
		mmVerifyToken.mock.t.Fatalf("JWTManagerMock.VerifyToken mock is already set by Set")
	}

	expectation := &JWTManagerMockVerifyTokenExpectation{
		mock:               mmVerifyToken.mock,
		params:             &JWTManagerMockVerifyTokenParams{tokenStr, secretKey},
		expectationOrigins: JWTManagerMockVerifyTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmVerifyToken.expectations = append(mmVerifyToken.expectations, expectation)
	return expectation
}

// Then sets up JWTManager.VerifyToken return parameters for the expectation previously defined by the When method
func (e *JWTManagerMockVerifyTokenExpectation) Then(up1 *model.UserClaims, err error) *JWTManagerMock {
	e.results = &JWTManagerMockVerifyTokenResults{up1, err}
	return e.mock
}

// Times sets number of times JWTManager.VerifyToken should be invoked
func (mmVerifyToken *mJWTManagerMockVerifyToken) Times(n uint64) *mJWTManagerMockVerifyToken {
	if n == 0 {
		mmVerifyToken.mock.t.Fatalf("Times of JWTManagerMock.VerifyToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmVerifyToken.expectedInvocations, n)
	mmVerifyToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmVerifyToken
}

func (mmVerifyToken *mJWTManagerMockVerifyToken) invocationsDone() bool {
	if len(mmVerifyToken.expectations) == 0 && mmVerifyToken.defaultExpectation == nil && mmVerifyToken.mock.funcVerifyToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmVerifyToken.mock.afterVerifyTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmVerifyToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// VerifyToken implements mm_jwt.JWTManager
func (mmVerifyToken *JWTManagerMock) VerifyToken(tokenStr string, secretKey []byte) (up1 *model.UserClaims, err error) {
	mm_atomic.AddUint64(&mmVerifyToken.beforeVerifyTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmVerifyToken.afterVerifyTokenCounter, 1)

	mmVerifyToken.t.Helper()

	if mmVerifyToken.inspectFuncVerifyToken != nil {
		mmVerifyToken.inspectFuncVerifyToken(tokenStr, secretKey)
	}

	mm_params := JWTManagerMockVerifyTokenParams{tokenStr, secretKey}

	// Record call args
	mmVerifyToken.VerifyTokenMock.mutex.Lock()
	mmVerifyToken.VerifyTokenMock.callArgs = append(mmVerifyToken.VerifyTokenMock.callArgs, &mm_params)
	mmVerifyToken.VerifyTokenMock.mutex.Unlock()

	for _, e := range mmVerifyToken.VerifyTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmVerifyToken.VerifyTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmVerifyToken.VerifyTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmVerifyToken.VerifyTokenMock.defaultExpectation.params
		mm_want_ptrs := mmVerifyToken.VerifyTokenMock.defaultExpectation.paramPtrs

		mm_got := JWTManagerMockVerifyTokenParams{tokenStr, secretKey}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.tokenStr != nil && !minimock.Equal(*mm_want_ptrs.tokenStr, mm_got.tokenStr) {
				mmVerifyToken.t.Errorf("JWTManagerMock.VerifyToken got unexpected parameter tokenStr, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyToken.VerifyTokenMock.defaultExpectation.expectationOrigins.originTokenStr, *mm_want_ptrs.tokenStr, mm_got.tokenStr, minimock.Diff(*mm_want_ptrs.tokenStr, mm_got.tokenStr))
			}

			if mm_want_ptrs.secretKey != nil && !minimock.Equal(*mm_want_ptrs.secretKey, mm_got.secretKey) {
				mmVerifyToken.t.Errorf("JWTManagerMock.VerifyToken got unexpected parameter secretKey, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmVerifyToken.VerifyTokenMock.defaultExpectation.expectationOrigins.originSecretKey, *mm_want_ptrs.secretKey, mm_got.secretKey, minimock.Diff(*mm_want_ptrs.secretKey, mm_got.secretKey))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmVerifyToken.t.Errorf("JWTManagerMock.VerifyToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmVerifyToken.VerifyTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmVerifyToken.VerifyTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmVerifyToken.t.Fatal("No results are set for the JWTManagerMock.VerifyToken")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmVerifyToken.funcVerifyToken != nil {
		return mmVerifyToken.funcVerifyToken(tokenStr, secretKey)
	}
	mmVerifyToken.t.Fatalf("Unexpected call to JWTManagerMock.VerifyToken. %v %v", tokenStr, secretKey)
	return
}

// VerifyTokenAfterCounter returns a count of finished JWTManagerMock.VerifyToken invocations
func (mmVerifyToken *JWTManagerMock) VerifyTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyToken.afterVerifyTokenCounter)
}

// VerifyTokenBeforeCounter returns a count of JWTManagerMock.VerifyToken invocations
func (mmVerifyToken *JWTManagerMock) VerifyTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmVerifyToken.beforeVerifyTokenCounter)
}

// Calls returns a list of arguments used in each call to JWTManagerMock.VerifyToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmVerifyToken *mJWTManagerMockVerifyToken) Calls() []*JWTManagerMockVerifyTokenParams {
	mmVerifyToken.mutex.RLock()

	argCopy := make([]*JWTManagerMockVerifyTokenParams, len(mmVerifyToken.callArgs))
	copy(argCopy, mmVerifyToken.callArgs)

	mmVerifyToken.mutex.RUnlock()

	return argCopy
}

// MinimockVerifyTokenDone returns true if the count of the VerifyToken invocations corresponds
// the number of defined expectations
func (m *JWTManagerMock) MinimockVerifyTokenDone() bool {
	if m.VerifyTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.VerifyTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.VerifyTokenMock.invocationsDone()
}

// MinimockVerifyTokenInspect logs each unmet expectation
func (m *JWTManagerMock) MinimockVerifyTokenInspect() {
	for _, e := range m.VerifyTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to JWTManagerMock.VerifyToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterVerifyTokenCounter := mm_atomic.LoadUint64(&m.afterVerifyTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.VerifyTokenMock.defaultExpectation != nil && afterVerifyTokenCounter < 1 {
		if m.VerifyTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to JWTManagerMock.VerifyToken at\n%s", m.VerifyTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to JWTManagerMock.VerifyToken at\n%s with params: %#v", m.VerifyTokenMock.defaultExpectation.expectationOrigins.origin, *m.VerifyTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcVerifyToken != nil && afterVerifyTokenCounter < 1 {
		m.t.Errorf("Expected call to JWTManagerMock.VerifyToken at\n%s", m.funcVerifyTokenOrigin)
	}

	if !m.VerifyTokenMock.invocationsDone() && afterVerifyTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to JWTManagerMock.VerifyToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.VerifyTokenMock.expectedInvocations), m.VerifyTokenMock.expectedInvocationsOrigin, afterVerifyTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *JWTManagerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGenerateTokenInspect()

			m.MinimockVerifyTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *JWTManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *JWTManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGenerateTokenDone() &&
		m.MinimockVerifyTokenDone()
}
