// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/GolZrd/micro-chat/auth/internal/repository/auth.AuthRepository -o auth_repository_minimock.go -n AuthRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	"time"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AuthRepositoryMock implements mm_auth.AuthRepository
type AuthRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateRefreshToken          func(ctx context.Context, userId int64, token string, expiers_at time.Time) (err error)
	funcCreateRefreshTokenOrigin    string
	inspectFuncCreateRefreshToken   func(ctx context.Context, userId int64, token string, expiers_at time.Time)
	afterCreateRefreshTokenCounter  uint64
	beforeCreateRefreshTokenCounter uint64
	CreateRefreshTokenMock          mAuthRepositoryMockCreateRefreshToken

	funcRevokeAllByUserId          func(ctx context.Context, userId int64) (err error)
	funcRevokeAllByUserIdOrigin    string
	inspectFuncRevokeAllByUserId   func(ctx context.Context, userId int64)
	afterRevokeAllByUserIdCounter  uint64
	beforeRevokeAllByUserIdCounter uint64
	RevokeAllByUserIdMock          mAuthRepositoryMockRevokeAllByUserId

	funcRevokeToken          func(ctx context.Context, token string) (err error)
	funcRevokeTokenOrigin    string
	inspectFuncRevokeToken   func(ctx context.Context, token string)
	afterRevokeTokenCounter  uint64
	beforeRevokeTokenCounter uint64
	RevokeTokenMock          mAuthRepositoryMockRevokeToken
}

// NewAuthRepositoryMock returns a mock for mm_auth.AuthRepository
func NewAuthRepositoryMock(t minimock.Tester) *AuthRepositoryMock {
	m := &AuthRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateRefreshTokenMock = mAuthRepositoryMockCreateRefreshToken{mock: m}
	m.CreateRefreshTokenMock.callArgs = []*AuthRepositoryMockCreateRefreshTokenParams{}

	m.RevokeAllByUserIdMock = mAuthRepositoryMockRevokeAllByUserId{mock: m}
	m.RevokeAllByUserIdMock.callArgs = []*AuthRepositoryMockRevokeAllByUserIdParams{}

	m.RevokeTokenMock = mAuthRepositoryMockRevokeToken{mock: m}
	m.RevokeTokenMock.callArgs = []*AuthRepositoryMockRevokeTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthRepositoryMockCreateRefreshToken struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockCreateRefreshTokenExpectation
	expectations       []*AuthRepositoryMockCreateRefreshTokenExpectation

	callArgs []*AuthRepositoryMockCreateRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockCreateRefreshTokenExpectation specifies expectation struct of the AuthRepository.CreateRefreshToken
type AuthRepositoryMockCreateRefreshTokenExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockCreateRefreshTokenParams
	paramPtrs          *AuthRepositoryMockCreateRefreshTokenParamPtrs
	expectationOrigins AuthRepositoryMockCreateRefreshTokenExpectationOrigins
	results            *AuthRepositoryMockCreateRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockCreateRefreshTokenParams contains parameters of the AuthRepository.CreateRefreshToken
type AuthRepositoryMockCreateRefreshTokenParams struct {
	ctx        context.Context
	userId     int64
	token      string
	expiers_at time.Time
}

// AuthRepositoryMockCreateRefreshTokenParamPtrs contains pointers to parameters of the AuthRepository.CreateRefreshToken
type AuthRepositoryMockCreateRefreshTokenParamPtrs struct {
	ctx        *context.Context
	userId     *int64
	token      *string
	expiers_at *time.Time
}

// AuthRepositoryMockCreateRefreshTokenResults contains results of the AuthRepository.CreateRefreshToken
type AuthRepositoryMockCreateRefreshTokenResults struct {
	err error
}

// AuthRepositoryMockCreateRefreshTokenOrigins contains origins of expectations of the AuthRepository.CreateRefreshToken
type AuthRepositoryMockCreateRefreshTokenExpectationOrigins struct {
	origin           string
	originCtx        string
	originUserId     string
	originToken      string
	originExpiers_at string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) Optional() *mAuthRepositoryMockCreateRefreshToken {
	mmCreateRefreshToken.optional = true
	return mmCreateRefreshToken
}

// Expect sets up expected params for AuthRepository.CreateRefreshToken
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) Expect(ctx context.Context, userId int64, token string, expiers_at time.Time) *mAuthRepositoryMockCreateRefreshToken {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	if mmCreateRefreshToken.defaultExpectation == nil {
		mmCreateRefreshToken.defaultExpectation = &AuthRepositoryMockCreateRefreshTokenExpectation{}
	}

	if mmCreateRefreshToken.defaultExpectation.paramPtrs != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by ExpectParams functions")
	}

	mmCreateRefreshToken.defaultExpectation.params = &AuthRepositoryMockCreateRefreshTokenParams{ctx, userId, token, expiers_at}
	mmCreateRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateRefreshToken.expectations {
		if minimock.Equal(e.params, mmCreateRefreshToken.defaultExpectation.params) {
			mmCreateRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateRefreshToken.defaultExpectation.params)
		}
	}

	return mmCreateRefreshToken
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.CreateRefreshToken
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockCreateRefreshToken {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	if mmCreateRefreshToken.defaultExpectation == nil {
		mmCreateRefreshToken.defaultExpectation = &AuthRepositoryMockCreateRefreshTokenExpectation{}
	}

	if mmCreateRefreshToken.defaultExpectation.params != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Expect")
	}

	if mmCreateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmCreateRefreshToken.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateRefreshTokenParamPtrs{}
	}
	mmCreateRefreshToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateRefreshToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateRefreshToken
}

// ExpectUserIdParam2 sets up expected param userId for AuthRepository.CreateRefreshToken
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) ExpectUserIdParam2(userId int64) *mAuthRepositoryMockCreateRefreshToken {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	if mmCreateRefreshToken.defaultExpectation == nil {
		mmCreateRefreshToken.defaultExpectation = &AuthRepositoryMockCreateRefreshTokenExpectation{}
	}

	if mmCreateRefreshToken.defaultExpectation.params != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Expect")
	}

	if mmCreateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmCreateRefreshToken.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateRefreshTokenParamPtrs{}
	}
	mmCreateRefreshToken.defaultExpectation.paramPtrs.userId = &userId
	mmCreateRefreshToken.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmCreateRefreshToken
}

// ExpectTokenParam3 sets up expected param token for AuthRepository.CreateRefreshToken
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) ExpectTokenParam3(token string) *mAuthRepositoryMockCreateRefreshToken {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	if mmCreateRefreshToken.defaultExpectation == nil {
		mmCreateRefreshToken.defaultExpectation = &AuthRepositoryMockCreateRefreshTokenExpectation{}
	}

	if mmCreateRefreshToken.defaultExpectation.params != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Expect")
	}

	if mmCreateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmCreateRefreshToken.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateRefreshTokenParamPtrs{}
	}
	mmCreateRefreshToken.defaultExpectation.paramPtrs.token = &token
	mmCreateRefreshToken.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmCreateRefreshToken
}

// ExpectExpiers_atParam4 sets up expected param expiers_at for AuthRepository.CreateRefreshToken
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) ExpectExpiers_atParam4(expiers_at time.Time) *mAuthRepositoryMockCreateRefreshToken {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	if mmCreateRefreshToken.defaultExpectation == nil {
		mmCreateRefreshToken.defaultExpectation = &AuthRepositoryMockCreateRefreshTokenExpectation{}
	}

	if mmCreateRefreshToken.defaultExpectation.params != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Expect")
	}

	if mmCreateRefreshToken.defaultExpectation.paramPtrs == nil {
		mmCreateRefreshToken.defaultExpectation.paramPtrs = &AuthRepositoryMockCreateRefreshTokenParamPtrs{}
	}
	mmCreateRefreshToken.defaultExpectation.paramPtrs.expiers_at = &expiers_at
	mmCreateRefreshToken.defaultExpectation.expectationOrigins.originExpiers_at = minimock.CallerInfo(1)

	return mmCreateRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.CreateRefreshToken
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) Inspect(f func(ctx context.Context, userId int64, token string, expiers_at time.Time)) *mAuthRepositoryMockCreateRefreshToken {
	if mmCreateRefreshToken.mock.inspectFuncCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.CreateRefreshToken")
	}

	mmCreateRefreshToken.mock.inspectFuncCreateRefreshToken = f

	return mmCreateRefreshToken
}

// Return sets up results that will be returned by AuthRepository.CreateRefreshToken
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) Return(err error) *AuthRepositoryMock {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	if mmCreateRefreshToken.defaultExpectation == nil {
		mmCreateRefreshToken.defaultExpectation = &AuthRepositoryMockCreateRefreshTokenExpectation{mock: mmCreateRefreshToken.mock}
	}
	mmCreateRefreshToken.defaultExpectation.results = &AuthRepositoryMockCreateRefreshTokenResults{err}
	mmCreateRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateRefreshToken.mock
}

// Set uses given function f to mock the AuthRepository.CreateRefreshToken method
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) Set(f func(ctx context.Context, userId int64, token string, expiers_at time.Time) (err error)) *AuthRepositoryMock {
	if mmCreateRefreshToken.defaultExpectation != nil {
		mmCreateRefreshToken.mock.t.Fatalf("Default expectation is already set for the AuthRepository.CreateRefreshToken method")
	}

	if len(mmCreateRefreshToken.expectations) > 0 {
		mmCreateRefreshToken.mock.t.Fatalf("Some expectations are already set for the AuthRepository.CreateRefreshToken method")
	}

	mmCreateRefreshToken.mock.funcCreateRefreshToken = f
	mmCreateRefreshToken.mock.funcCreateRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmCreateRefreshToken.mock
}

// When sets expectation for the AuthRepository.CreateRefreshToken which will trigger the result defined by the following
// Then helper
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) When(ctx context.Context, userId int64, token string, expiers_at time.Time) *AuthRepositoryMockCreateRefreshTokenExpectation {
	if mmCreateRefreshToken.mock.funcCreateRefreshToken != nil {
		mmCreateRefreshToken.mock.t.Fatalf("AuthRepositoryMock.CreateRefreshToken mock is already set by Set")
	}

	expectation := &AuthRepositoryMockCreateRefreshTokenExpectation{
		mock:               mmCreateRefreshToken.mock,
		params:             &AuthRepositoryMockCreateRefreshTokenParams{ctx, userId, token, expiers_at},
		expectationOrigins: AuthRepositoryMockCreateRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateRefreshToken.expectations = append(mmCreateRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.CreateRefreshToken return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockCreateRefreshTokenExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockCreateRefreshTokenResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.CreateRefreshToken should be invoked
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) Times(n uint64) *mAuthRepositoryMockCreateRefreshToken {
	if n == 0 {
		mmCreateRefreshToken.mock.t.Fatalf("Times of AuthRepositoryMock.CreateRefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateRefreshToken.expectedInvocations, n)
	mmCreateRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateRefreshToken
}

func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) invocationsDone() bool {
	if len(mmCreateRefreshToken.expectations) == 0 && mmCreateRefreshToken.defaultExpectation == nil && mmCreateRefreshToken.mock.funcCreateRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateRefreshToken.mock.afterCreateRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateRefreshToken implements mm_auth.AuthRepository
func (mmCreateRefreshToken *AuthRepositoryMock) CreateRefreshToken(ctx context.Context, userId int64, token string, expiers_at time.Time) (err error) {
	mm_atomic.AddUint64(&mmCreateRefreshToken.beforeCreateRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateRefreshToken.afterCreateRefreshTokenCounter, 1)

	mmCreateRefreshToken.t.Helper()

	if mmCreateRefreshToken.inspectFuncCreateRefreshToken != nil {
		mmCreateRefreshToken.inspectFuncCreateRefreshToken(ctx, userId, token, expiers_at)
	}

	mm_params := AuthRepositoryMockCreateRefreshTokenParams{ctx, userId, token, expiers_at}

	// Record call args
	mmCreateRefreshToken.CreateRefreshTokenMock.mutex.Lock()
	mmCreateRefreshToken.CreateRefreshTokenMock.callArgs = append(mmCreateRefreshToken.CreateRefreshTokenMock.callArgs, &mm_params)
	mmCreateRefreshToken.CreateRefreshTokenMock.mutex.Unlock()

	for _, e := range mmCreateRefreshToken.CreateRefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockCreateRefreshTokenParams{ctx, userId, token, expiers_at}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateRefreshToken.t.Errorf("AuthRepositoryMock.CreateRefreshToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmCreateRefreshToken.t.Errorf("AuthRepositoryMock.CreateRefreshToken got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmCreateRefreshToken.t.Errorf("AuthRepositoryMock.CreateRefreshToken got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

			if mm_want_ptrs.expiers_at != nil && !minimock.Equal(*mm_want_ptrs.expiers_at, mm_got.expiers_at) {
				mmCreateRefreshToken.t.Errorf("AuthRepositoryMock.CreateRefreshToken got unexpected parameter expiers_at, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.expectationOrigins.originExpiers_at, *mm_want_ptrs.expiers_at, mm_got.expiers_at, minimock.Diff(*mm_want_ptrs.expiers_at, mm_got.expiers_at))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateRefreshToken.t.Errorf("AuthRepositoryMock.CreateRefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateRefreshToken.CreateRefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateRefreshToken.t.Fatal("No results are set for the AuthRepositoryMock.CreateRefreshToken")
		}
		return (*mm_results).err
	}
	if mmCreateRefreshToken.funcCreateRefreshToken != nil {
		return mmCreateRefreshToken.funcCreateRefreshToken(ctx, userId, token, expiers_at)
	}
	mmCreateRefreshToken.t.Fatalf("Unexpected call to AuthRepositoryMock.CreateRefreshToken. %v %v %v %v", ctx, userId, token, expiers_at)
	return
}

// CreateRefreshTokenAfterCounter returns a count of finished AuthRepositoryMock.CreateRefreshToken invocations
func (mmCreateRefreshToken *AuthRepositoryMock) CreateRefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRefreshToken.afterCreateRefreshTokenCounter)
}

// CreateRefreshTokenBeforeCounter returns a count of AuthRepositoryMock.CreateRefreshToken invocations
func (mmCreateRefreshToken *AuthRepositoryMock) CreateRefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateRefreshToken.beforeCreateRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.CreateRefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateRefreshToken *mAuthRepositoryMockCreateRefreshToken) Calls() []*AuthRepositoryMockCreateRefreshTokenParams {
	mmCreateRefreshToken.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockCreateRefreshTokenParams, len(mmCreateRefreshToken.callArgs))
	copy(argCopy, mmCreateRefreshToken.callArgs)

	mmCreateRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockCreateRefreshTokenDone returns true if the count of the CreateRefreshToken invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockCreateRefreshTokenDone() bool {
	if m.CreateRefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateRefreshTokenMock.invocationsDone()
}

// MinimockCreateRefreshTokenInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockCreateRefreshTokenInspect() {
	for _, e := range m.CreateRefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateRefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterCreateRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateRefreshTokenMock.defaultExpectation != nil && afterCreateRefreshTokenCounter < 1 {
		if m.CreateRefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateRefreshToken at\n%s", m.CreateRefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.CreateRefreshToken at\n%s with params: %#v", m.CreateRefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.CreateRefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateRefreshToken != nil && afterCreateRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.CreateRefreshToken at\n%s", m.funcCreateRefreshTokenOrigin)
	}

	if !m.CreateRefreshTokenMock.invocationsDone() && afterCreateRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.CreateRefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateRefreshTokenMock.expectedInvocations), m.CreateRefreshTokenMock.expectedInvocationsOrigin, afterCreateRefreshTokenCounter)
	}
}

type mAuthRepositoryMockRevokeAllByUserId struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockRevokeAllByUserIdExpectation
	expectations       []*AuthRepositoryMockRevokeAllByUserIdExpectation

	callArgs []*AuthRepositoryMockRevokeAllByUserIdParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockRevokeAllByUserIdExpectation specifies expectation struct of the AuthRepository.RevokeAllByUserId
type AuthRepositoryMockRevokeAllByUserIdExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockRevokeAllByUserIdParams
	paramPtrs          *AuthRepositoryMockRevokeAllByUserIdParamPtrs
	expectationOrigins AuthRepositoryMockRevokeAllByUserIdExpectationOrigins
	results            *AuthRepositoryMockRevokeAllByUserIdResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockRevokeAllByUserIdParams contains parameters of the AuthRepository.RevokeAllByUserId
type AuthRepositoryMockRevokeAllByUserIdParams struct {
	ctx    context.Context
	userId int64
}

// AuthRepositoryMockRevokeAllByUserIdParamPtrs contains pointers to parameters of the AuthRepository.RevokeAllByUserId
type AuthRepositoryMockRevokeAllByUserIdParamPtrs struct {
	ctx    *context.Context
	userId *int64
}

// AuthRepositoryMockRevokeAllByUserIdResults contains results of the AuthRepository.RevokeAllByUserId
type AuthRepositoryMockRevokeAllByUserIdResults struct {
	err error
}

// AuthRepositoryMockRevokeAllByUserIdOrigins contains origins of expectations of the AuthRepository.RevokeAllByUserId
type AuthRepositoryMockRevokeAllByUserIdExpectationOrigins struct {
	origin       string
	originCtx    string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) Optional() *mAuthRepositoryMockRevokeAllByUserId {
	mmRevokeAllByUserId.optional = true
	return mmRevokeAllByUserId
}

// Expect sets up expected params for AuthRepository.RevokeAllByUserId
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) Expect(ctx context.Context, userId int64) *mAuthRepositoryMockRevokeAllByUserId {
	if mmRevokeAllByUserId.mock.funcRevokeAllByUserId != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("AuthRepositoryMock.RevokeAllByUserId mock is already set by Set")
	}

	if mmRevokeAllByUserId.defaultExpectation == nil {
		mmRevokeAllByUserId.defaultExpectation = &AuthRepositoryMockRevokeAllByUserIdExpectation{}
	}

	if mmRevokeAllByUserId.defaultExpectation.paramPtrs != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("AuthRepositoryMock.RevokeAllByUserId mock is already set by ExpectParams functions")
	}

	mmRevokeAllByUserId.defaultExpectation.params = &AuthRepositoryMockRevokeAllByUserIdParams{ctx, userId}
	mmRevokeAllByUserId.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRevokeAllByUserId.expectations {
		if minimock.Equal(e.params, mmRevokeAllByUserId.defaultExpectation.params) {
			mmRevokeAllByUserId.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRevokeAllByUserId.defaultExpectation.params)
		}
	}

	return mmRevokeAllByUserId
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.RevokeAllByUserId
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockRevokeAllByUserId {
	if mmRevokeAllByUserId.mock.funcRevokeAllByUserId != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("AuthRepositoryMock.RevokeAllByUserId mock is already set by Set")
	}

	if mmRevokeAllByUserId.defaultExpectation == nil {
		mmRevokeAllByUserId.defaultExpectation = &AuthRepositoryMockRevokeAllByUserIdExpectation{}
	}

	if mmRevokeAllByUserId.defaultExpectation.params != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("AuthRepositoryMock.RevokeAllByUserId mock is already set by Expect")
	}

	if mmRevokeAllByUserId.defaultExpectation.paramPtrs == nil {
		mmRevokeAllByUserId.defaultExpectation.paramPtrs = &AuthRepositoryMockRevokeAllByUserIdParamPtrs{}
	}
	mmRevokeAllByUserId.defaultExpectation.paramPtrs.ctx = &ctx
	mmRevokeAllByUserId.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRevokeAllByUserId
}

// ExpectUserIdParam2 sets up expected param userId for AuthRepository.RevokeAllByUserId
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) ExpectUserIdParam2(userId int64) *mAuthRepositoryMockRevokeAllByUserId {
	if mmRevokeAllByUserId.mock.funcRevokeAllByUserId != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("AuthRepositoryMock.RevokeAllByUserId mock is already set by Set")
	}

	if mmRevokeAllByUserId.defaultExpectation == nil {
		mmRevokeAllByUserId.defaultExpectation = &AuthRepositoryMockRevokeAllByUserIdExpectation{}
	}

	if mmRevokeAllByUserId.defaultExpectation.params != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("AuthRepositoryMock.RevokeAllByUserId mock is already set by Expect")
	}

	if mmRevokeAllByUserId.defaultExpectation.paramPtrs == nil {
		mmRevokeAllByUserId.defaultExpectation.paramPtrs = &AuthRepositoryMockRevokeAllByUserIdParamPtrs{}
	}
	mmRevokeAllByUserId.defaultExpectation.paramPtrs.userId = &userId
	mmRevokeAllByUserId.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmRevokeAllByUserId
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.RevokeAllByUserId
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) Inspect(f func(ctx context.Context, userId int64)) *mAuthRepositoryMockRevokeAllByUserId {
	if mmRevokeAllByUserId.mock.inspectFuncRevokeAllByUserId != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.RevokeAllByUserId")
	}

	mmRevokeAllByUserId.mock.inspectFuncRevokeAllByUserId = f

	return mmRevokeAllByUserId
}

// Return sets up results that will be returned by AuthRepository.RevokeAllByUserId
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) Return(err error) *AuthRepositoryMock {
	if mmRevokeAllByUserId.mock.funcRevokeAllByUserId != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("AuthRepositoryMock.RevokeAllByUserId mock is already set by Set")
	}

	if mmRevokeAllByUserId.defaultExpectation == nil {
		mmRevokeAllByUserId.defaultExpectation = &AuthRepositoryMockRevokeAllByUserIdExpectation{mock: mmRevokeAllByUserId.mock}
	}
	mmRevokeAllByUserId.defaultExpectation.results = &AuthRepositoryMockRevokeAllByUserIdResults{err}
	mmRevokeAllByUserId.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRevokeAllByUserId.mock
}

// Set uses given function f to mock the AuthRepository.RevokeAllByUserId method
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) Set(f func(ctx context.Context, userId int64) (err error)) *AuthRepositoryMock {
	if mmRevokeAllByUserId.defaultExpectation != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("Default expectation is already set for the AuthRepository.RevokeAllByUserId method")
	}

	if len(mmRevokeAllByUserId.expectations) > 0 {
		mmRevokeAllByUserId.mock.t.Fatalf("Some expectations are already set for the AuthRepository.RevokeAllByUserId method")
	}

	mmRevokeAllByUserId.mock.funcRevokeAllByUserId = f
	mmRevokeAllByUserId.mock.funcRevokeAllByUserIdOrigin = minimock.CallerInfo(1)
	return mmRevokeAllByUserId.mock
}

// When sets expectation for the AuthRepository.RevokeAllByUserId which will trigger the result defined by the following
// Then helper
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) When(ctx context.Context, userId int64) *AuthRepositoryMockRevokeAllByUserIdExpectation {
	if mmRevokeAllByUserId.mock.funcRevokeAllByUserId != nil {
		mmRevokeAllByUserId.mock.t.Fatalf("AuthRepositoryMock.RevokeAllByUserId mock is already set by Set")
	}

	expectation := &AuthRepositoryMockRevokeAllByUserIdExpectation{
		mock:               mmRevokeAllByUserId.mock,
		params:             &AuthRepositoryMockRevokeAllByUserIdParams{ctx, userId},
		expectationOrigins: AuthRepositoryMockRevokeAllByUserIdExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRevokeAllByUserId.expectations = append(mmRevokeAllByUserId.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.RevokeAllByUserId return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockRevokeAllByUserIdExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockRevokeAllByUserIdResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.RevokeAllByUserId should be invoked
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) Times(n uint64) *mAuthRepositoryMockRevokeAllByUserId {
	if n == 0 {
		mmRevokeAllByUserId.mock.t.Fatalf("Times of AuthRepositoryMock.RevokeAllByUserId mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRevokeAllByUserId.expectedInvocations, n)
	mmRevokeAllByUserId.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRevokeAllByUserId
}

func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) invocationsDone() bool {
	if len(mmRevokeAllByUserId.expectations) == 0 && mmRevokeAllByUserId.defaultExpectation == nil && mmRevokeAllByUserId.mock.funcRevokeAllByUserId == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRevokeAllByUserId.mock.afterRevokeAllByUserIdCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRevokeAllByUserId.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RevokeAllByUserId implements mm_auth.AuthRepository
func (mmRevokeAllByUserId *AuthRepositoryMock) RevokeAllByUserId(ctx context.Context, userId int64) (err error) {
	mm_atomic.AddUint64(&mmRevokeAllByUserId.beforeRevokeAllByUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmRevokeAllByUserId.afterRevokeAllByUserIdCounter, 1)

	mmRevokeAllByUserId.t.Helper()

	if mmRevokeAllByUserId.inspectFuncRevokeAllByUserId != nil {
		mmRevokeAllByUserId.inspectFuncRevokeAllByUserId(ctx, userId)
	}

	mm_params := AuthRepositoryMockRevokeAllByUserIdParams{ctx, userId}

	// Record call args
	mmRevokeAllByUserId.RevokeAllByUserIdMock.mutex.Lock()
	mmRevokeAllByUserId.RevokeAllByUserIdMock.callArgs = append(mmRevokeAllByUserId.RevokeAllByUserIdMock.callArgs, &mm_params)
	mmRevokeAllByUserId.RevokeAllByUserIdMock.mutex.Unlock()

	for _, e := range mmRevokeAllByUserId.RevokeAllByUserIdMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRevokeAllByUserId.RevokeAllByUserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRevokeAllByUserId.RevokeAllByUserIdMock.defaultExpectation.Counter, 1)
		mm_want := mmRevokeAllByUserId.RevokeAllByUserIdMock.defaultExpectation.params
		mm_want_ptrs := mmRevokeAllByUserId.RevokeAllByUserIdMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockRevokeAllByUserIdParams{ctx, userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRevokeAllByUserId.t.Errorf("AuthRepositoryMock.RevokeAllByUserId got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRevokeAllByUserId.RevokeAllByUserIdMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmRevokeAllByUserId.t.Errorf("AuthRepositoryMock.RevokeAllByUserId got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRevokeAllByUserId.RevokeAllByUserIdMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRevokeAllByUserId.t.Errorf("AuthRepositoryMock.RevokeAllByUserId got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRevokeAllByUserId.RevokeAllByUserIdMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRevokeAllByUserId.RevokeAllByUserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmRevokeAllByUserId.t.Fatal("No results are set for the AuthRepositoryMock.RevokeAllByUserId")
		}
		return (*mm_results).err
	}
	if mmRevokeAllByUserId.funcRevokeAllByUserId != nil {
		return mmRevokeAllByUserId.funcRevokeAllByUserId(ctx, userId)
	}
	mmRevokeAllByUserId.t.Fatalf("Unexpected call to AuthRepositoryMock.RevokeAllByUserId. %v %v", ctx, userId)
	return
}

// RevokeAllByUserIdAfterCounter returns a count of finished AuthRepositoryMock.RevokeAllByUserId invocations
func (mmRevokeAllByUserId *AuthRepositoryMock) RevokeAllByUserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeAllByUserId.afterRevokeAllByUserIdCounter)
}

// RevokeAllByUserIdBeforeCounter returns a count of AuthRepositoryMock.RevokeAllByUserId invocations
func (mmRevokeAllByUserId *AuthRepositoryMock) RevokeAllByUserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeAllByUserId.beforeRevokeAllByUserIdCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.RevokeAllByUserId.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRevokeAllByUserId *mAuthRepositoryMockRevokeAllByUserId) Calls() []*AuthRepositoryMockRevokeAllByUserIdParams {
	mmRevokeAllByUserId.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockRevokeAllByUserIdParams, len(mmRevokeAllByUserId.callArgs))
	copy(argCopy, mmRevokeAllByUserId.callArgs)

	mmRevokeAllByUserId.mutex.RUnlock()

	return argCopy
}

// MinimockRevokeAllByUserIdDone returns true if the count of the RevokeAllByUserId invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockRevokeAllByUserIdDone() bool {
	if m.RevokeAllByUserIdMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RevokeAllByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RevokeAllByUserIdMock.invocationsDone()
}

// MinimockRevokeAllByUserIdInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockRevokeAllByUserIdInspect() {
	for _, e := range m.RevokeAllByUserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.RevokeAllByUserId at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRevokeAllByUserIdCounter := mm_atomic.LoadUint64(&m.afterRevokeAllByUserIdCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RevokeAllByUserIdMock.defaultExpectation != nil && afterRevokeAllByUserIdCounter < 1 {
		if m.RevokeAllByUserIdMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.RevokeAllByUserId at\n%s", m.RevokeAllByUserIdMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.RevokeAllByUserId at\n%s with params: %#v", m.RevokeAllByUserIdMock.defaultExpectation.expectationOrigins.origin, *m.RevokeAllByUserIdMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRevokeAllByUserId != nil && afterRevokeAllByUserIdCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.RevokeAllByUserId at\n%s", m.funcRevokeAllByUserIdOrigin)
	}

	if !m.RevokeAllByUserIdMock.invocationsDone() && afterRevokeAllByUserIdCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.RevokeAllByUserId at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RevokeAllByUserIdMock.expectedInvocations), m.RevokeAllByUserIdMock.expectedInvocationsOrigin, afterRevokeAllByUserIdCounter)
	}
}

type mAuthRepositoryMockRevokeToken struct {
	optional           bool
	mock               *AuthRepositoryMock
	defaultExpectation *AuthRepositoryMockRevokeTokenExpectation
	expectations       []*AuthRepositoryMockRevokeTokenExpectation

	callArgs []*AuthRepositoryMockRevokeTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthRepositoryMockRevokeTokenExpectation specifies expectation struct of the AuthRepository.RevokeToken
type AuthRepositoryMockRevokeTokenExpectation struct {
	mock               *AuthRepositoryMock
	params             *AuthRepositoryMockRevokeTokenParams
	paramPtrs          *AuthRepositoryMockRevokeTokenParamPtrs
	expectationOrigins AuthRepositoryMockRevokeTokenExpectationOrigins
	results            *AuthRepositoryMockRevokeTokenResults
	returnOrigin       string
	Counter            uint64
}

// AuthRepositoryMockRevokeTokenParams contains parameters of the AuthRepository.RevokeToken
type AuthRepositoryMockRevokeTokenParams struct {
	ctx   context.Context
	token string
}

// AuthRepositoryMockRevokeTokenParamPtrs contains pointers to parameters of the AuthRepository.RevokeToken
type AuthRepositoryMockRevokeTokenParamPtrs struct {
	ctx   *context.Context
	token *string
}

// AuthRepositoryMockRevokeTokenResults contains results of the AuthRepository.RevokeToken
type AuthRepositoryMockRevokeTokenResults struct {
	err error
}

// AuthRepositoryMockRevokeTokenOrigins contains origins of expectations of the AuthRepository.RevokeToken
type AuthRepositoryMockRevokeTokenExpectationOrigins struct {
	origin      string
	originCtx   string
	originToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) Optional() *mAuthRepositoryMockRevokeToken {
	mmRevokeToken.optional = true
	return mmRevokeToken
}

// Expect sets up expected params for AuthRepository.RevokeToken
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) Expect(ctx context.Context, token string) *mAuthRepositoryMockRevokeToken {
	if mmRevokeToken.mock.funcRevokeToken != nil {
		mmRevokeToken.mock.t.Fatalf("AuthRepositoryMock.RevokeToken mock is already set by Set")
	}

	if mmRevokeToken.defaultExpectation == nil {
		mmRevokeToken.defaultExpectation = &AuthRepositoryMockRevokeTokenExpectation{}
	}

	if mmRevokeToken.defaultExpectation.paramPtrs != nil {
		mmRevokeToken.mock.t.Fatalf("AuthRepositoryMock.RevokeToken mock is already set by ExpectParams functions")
	}

	mmRevokeToken.defaultExpectation.params = &AuthRepositoryMockRevokeTokenParams{ctx, token}
	mmRevokeToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRevokeToken.expectations {
		if minimock.Equal(e.params, mmRevokeToken.defaultExpectation.params) {
			mmRevokeToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRevokeToken.defaultExpectation.params)
		}
	}

	return mmRevokeToken
}

// ExpectCtxParam1 sets up expected param ctx for AuthRepository.RevokeToken
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) ExpectCtxParam1(ctx context.Context) *mAuthRepositoryMockRevokeToken {
	if mmRevokeToken.mock.funcRevokeToken != nil {
		mmRevokeToken.mock.t.Fatalf("AuthRepositoryMock.RevokeToken mock is already set by Set")
	}

	if mmRevokeToken.defaultExpectation == nil {
		mmRevokeToken.defaultExpectation = &AuthRepositoryMockRevokeTokenExpectation{}
	}

	if mmRevokeToken.defaultExpectation.params != nil {
		mmRevokeToken.mock.t.Fatalf("AuthRepositoryMock.RevokeToken mock is already set by Expect")
	}

	if mmRevokeToken.defaultExpectation.paramPtrs == nil {
		mmRevokeToken.defaultExpectation.paramPtrs = &AuthRepositoryMockRevokeTokenParamPtrs{}
	}
	mmRevokeToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmRevokeToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRevokeToken
}

// ExpectTokenParam2 sets up expected param token for AuthRepository.RevokeToken
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) ExpectTokenParam2(token string) *mAuthRepositoryMockRevokeToken {
	if mmRevokeToken.mock.funcRevokeToken != nil {
		mmRevokeToken.mock.t.Fatalf("AuthRepositoryMock.RevokeToken mock is already set by Set")
	}

	if mmRevokeToken.defaultExpectation == nil {
		mmRevokeToken.defaultExpectation = &AuthRepositoryMockRevokeTokenExpectation{}
	}

	if mmRevokeToken.defaultExpectation.params != nil {
		mmRevokeToken.mock.t.Fatalf("AuthRepositoryMock.RevokeToken mock is already set by Expect")
	}

	if mmRevokeToken.defaultExpectation.paramPtrs == nil {
		mmRevokeToken.defaultExpectation.paramPtrs = &AuthRepositoryMockRevokeTokenParamPtrs{}
	}
	mmRevokeToken.defaultExpectation.paramPtrs.token = &token
	mmRevokeToken.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmRevokeToken
}

// Inspect accepts an inspector function that has same arguments as the AuthRepository.RevokeToken
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) Inspect(f func(ctx context.Context, token string)) *mAuthRepositoryMockRevokeToken {
	if mmRevokeToken.mock.inspectFuncRevokeToken != nil {
		mmRevokeToken.mock.t.Fatalf("Inspect function is already set for AuthRepositoryMock.RevokeToken")
	}

	mmRevokeToken.mock.inspectFuncRevokeToken = f

	return mmRevokeToken
}

// Return sets up results that will be returned by AuthRepository.RevokeToken
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) Return(err error) *AuthRepositoryMock {
	if mmRevokeToken.mock.funcRevokeToken != nil {
		mmRevokeToken.mock.t.Fatalf("AuthRepositoryMock.RevokeToken mock is already set by Set")
	}

	if mmRevokeToken.defaultExpectation == nil {
		mmRevokeToken.defaultExpectation = &AuthRepositoryMockRevokeTokenExpectation{mock: mmRevokeToken.mock}
	}
	mmRevokeToken.defaultExpectation.results = &AuthRepositoryMockRevokeTokenResults{err}
	mmRevokeToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRevokeToken.mock
}

// Set uses given function f to mock the AuthRepository.RevokeToken method
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) Set(f func(ctx context.Context, token string) (err error)) *AuthRepositoryMock {
	if mmRevokeToken.defaultExpectation != nil {
		mmRevokeToken.mock.t.Fatalf("Default expectation is already set for the AuthRepository.RevokeToken method")
	}

	if len(mmRevokeToken.expectations) > 0 {
		mmRevokeToken.mock.t.Fatalf("Some expectations are already set for the AuthRepository.RevokeToken method")
	}

	mmRevokeToken.mock.funcRevokeToken = f
	mmRevokeToken.mock.funcRevokeTokenOrigin = minimock.CallerInfo(1)
	return mmRevokeToken.mock
}

// When sets expectation for the AuthRepository.RevokeToken which will trigger the result defined by the following
// Then helper
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) When(ctx context.Context, token string) *AuthRepositoryMockRevokeTokenExpectation {
	if mmRevokeToken.mock.funcRevokeToken != nil {
		mmRevokeToken.mock.t.Fatalf("AuthRepositoryMock.RevokeToken mock is already set by Set")
	}

	expectation := &AuthRepositoryMockRevokeTokenExpectation{
		mock:               mmRevokeToken.mock,
		params:             &AuthRepositoryMockRevokeTokenParams{ctx, token},
		expectationOrigins: AuthRepositoryMockRevokeTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRevokeToken.expectations = append(mmRevokeToken.expectations, expectation)
	return expectation
}

// Then sets up AuthRepository.RevokeToken return parameters for the expectation previously defined by the When method
func (e *AuthRepositoryMockRevokeTokenExpectation) Then(err error) *AuthRepositoryMock {
	e.results = &AuthRepositoryMockRevokeTokenResults{err}
	return e.mock
}

// Times sets number of times AuthRepository.RevokeToken should be invoked
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) Times(n uint64) *mAuthRepositoryMockRevokeToken {
	if n == 0 {
		mmRevokeToken.mock.t.Fatalf("Times of AuthRepositoryMock.RevokeToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRevokeToken.expectedInvocations, n)
	mmRevokeToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRevokeToken
}

func (mmRevokeToken *mAuthRepositoryMockRevokeToken) invocationsDone() bool {
	if len(mmRevokeToken.expectations) == 0 && mmRevokeToken.defaultExpectation == nil && mmRevokeToken.mock.funcRevokeToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRevokeToken.mock.afterRevokeTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRevokeToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RevokeToken implements mm_auth.AuthRepository
func (mmRevokeToken *AuthRepositoryMock) RevokeToken(ctx context.Context, token string) (err error) {
	mm_atomic.AddUint64(&mmRevokeToken.beforeRevokeTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmRevokeToken.afterRevokeTokenCounter, 1)

	mmRevokeToken.t.Helper()

	if mmRevokeToken.inspectFuncRevokeToken != nil {
		mmRevokeToken.inspectFuncRevokeToken(ctx, token)
	}

	mm_params := AuthRepositoryMockRevokeTokenParams{ctx, token}

	// Record call args
	mmRevokeToken.RevokeTokenMock.mutex.Lock()
	mmRevokeToken.RevokeTokenMock.callArgs = append(mmRevokeToken.RevokeTokenMock.callArgs, &mm_params)
	mmRevokeToken.RevokeTokenMock.mutex.Unlock()

	for _, e := range mmRevokeToken.RevokeTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRevokeToken.RevokeTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRevokeToken.RevokeTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmRevokeToken.RevokeTokenMock.defaultExpectation.params
		mm_want_ptrs := mmRevokeToken.RevokeTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthRepositoryMockRevokeTokenParams{ctx, token}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRevokeToken.t.Errorf("AuthRepositoryMock.RevokeToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRevokeToken.RevokeTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmRevokeToken.t.Errorf("AuthRepositoryMock.RevokeToken got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRevokeToken.RevokeTokenMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRevokeToken.t.Errorf("AuthRepositoryMock.RevokeToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRevokeToken.RevokeTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRevokeToken.RevokeTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmRevokeToken.t.Fatal("No results are set for the AuthRepositoryMock.RevokeToken")
		}
		return (*mm_results).err
	}
	if mmRevokeToken.funcRevokeToken != nil {
		return mmRevokeToken.funcRevokeToken(ctx, token)
	}
	mmRevokeToken.t.Fatalf("Unexpected call to AuthRepositoryMock.RevokeToken. %v %v", ctx, token)
	return
}

// RevokeTokenAfterCounter returns a count of finished AuthRepositoryMock.RevokeToken invocations
func (mmRevokeToken *AuthRepositoryMock) RevokeTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeToken.afterRevokeTokenCounter)
}

// RevokeTokenBeforeCounter returns a count of AuthRepositoryMock.RevokeToken invocations
func (mmRevokeToken *AuthRepositoryMock) RevokeTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRevokeToken.beforeRevokeTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthRepositoryMock.RevokeToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRevokeToken *mAuthRepositoryMockRevokeToken) Calls() []*AuthRepositoryMockRevokeTokenParams {
	mmRevokeToken.mutex.RLock()

	argCopy := make([]*AuthRepositoryMockRevokeTokenParams, len(mmRevokeToken.callArgs))
	copy(argCopy, mmRevokeToken.callArgs)

	mmRevokeToken.mutex.RUnlock()

	return argCopy
}

// MinimockRevokeTokenDone returns true if the count of the RevokeToken invocations corresponds
// the number of defined expectations
func (m *AuthRepositoryMock) MinimockRevokeTokenDone() bool {
	if m.RevokeTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RevokeTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RevokeTokenMock.invocationsDone()
}

// MinimockRevokeTokenInspect logs each unmet expectation
func (m *AuthRepositoryMock) MinimockRevokeTokenInspect() {
	for _, e := range m.RevokeTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthRepositoryMock.RevokeToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRevokeTokenCounter := mm_atomic.LoadUint64(&m.afterRevokeTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RevokeTokenMock.defaultExpectation != nil && afterRevokeTokenCounter < 1 {
		if m.RevokeTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthRepositoryMock.RevokeToken at\n%s", m.RevokeTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthRepositoryMock.RevokeToken at\n%s with params: %#v", m.RevokeTokenMock.defaultExpectation.expectationOrigins.origin, *m.RevokeTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRevokeToken != nil && afterRevokeTokenCounter < 1 {
		m.t.Errorf("Expected call to AuthRepositoryMock.RevokeToken at\n%s", m.funcRevokeTokenOrigin)
	}

	if !m.RevokeTokenMock.invocationsDone() && afterRevokeTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthRepositoryMock.RevokeToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RevokeTokenMock.expectedInvocations), m.RevokeTokenMock.expectedInvocationsOrigin, afterRevokeTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateRefreshTokenInspect()

			m.MinimockRevokeAllByUserIdInspect()

			m.MinimockRevokeTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateRefreshTokenDone() &&
		m.MinimockRevokeAllByUserIdDone() &&
		m.MinimockRevokeTokenDone()
}
