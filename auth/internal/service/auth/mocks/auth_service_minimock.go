// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/GolZrd/micro-chat/auth/internal/service/auth.AuthService -o auth_service_minimock.go -n AuthServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// AuthServiceMock implements mm_auth.AuthService
type AuthServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAccessToken          func(ctx context.Context, refreshToken string) (accessToken string, err error)
	funcAccessTokenOrigin    string
	inspectFuncAccessToken   func(ctx context.Context, refreshToken string)
	afterAccessTokenCounter  uint64
	beforeAccessTokenCounter uint64
	AccessTokenMock          mAuthServiceMockAccessToken

	funcLogin          func(ctx context.Context, email string, password string) (refreshToken string, userId int64, err error)
	funcLoginOrigin    string
	inspectFuncLogin   func(ctx context.Context, email string, password string)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mAuthServiceMockLogin

	funcRefreshToken          func(ctx context.Context, oldRefreshToken string) (refreshToken string, err error)
	funcRefreshTokenOrigin    string
	inspectFuncRefreshToken   func(ctx context.Context, oldRefreshToken string)
	afterRefreshTokenCounter  uint64
	beforeRefreshTokenCounter uint64
	RefreshTokenMock          mAuthServiceMockRefreshToken
}

// NewAuthServiceMock returns a mock for mm_auth.AuthService
func NewAuthServiceMock(t minimock.Tester) *AuthServiceMock {
	m := &AuthServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AccessTokenMock = mAuthServiceMockAccessToken{mock: m}
	m.AccessTokenMock.callArgs = []*AuthServiceMockAccessTokenParams{}

	m.LoginMock = mAuthServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*AuthServiceMockLoginParams{}

	m.RefreshTokenMock = mAuthServiceMockRefreshToken{mock: m}
	m.RefreshTokenMock.callArgs = []*AuthServiceMockRefreshTokenParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthServiceMockAccessToken struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockAccessTokenExpectation
	expectations       []*AuthServiceMockAccessTokenExpectation

	callArgs []*AuthServiceMockAccessTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockAccessTokenExpectation specifies expectation struct of the AuthService.AccessToken
type AuthServiceMockAccessTokenExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockAccessTokenParams
	paramPtrs          *AuthServiceMockAccessTokenParamPtrs
	expectationOrigins AuthServiceMockAccessTokenExpectationOrigins
	results            *AuthServiceMockAccessTokenResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockAccessTokenParams contains parameters of the AuthService.AccessToken
type AuthServiceMockAccessTokenParams struct {
	ctx          context.Context
	refreshToken string
}

// AuthServiceMockAccessTokenParamPtrs contains pointers to parameters of the AuthService.AccessToken
type AuthServiceMockAccessTokenParamPtrs struct {
	ctx          *context.Context
	refreshToken *string
}

// AuthServiceMockAccessTokenResults contains results of the AuthService.AccessToken
type AuthServiceMockAccessTokenResults struct {
	accessToken string
	err         error
}

// AuthServiceMockAccessTokenOrigins contains origins of expectations of the AuthService.AccessToken
type AuthServiceMockAccessTokenExpectationOrigins struct {
	origin             string
	originCtx          string
	originRefreshToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAccessToken *mAuthServiceMockAccessToken) Optional() *mAuthServiceMockAccessToken {
	mmAccessToken.optional = true
	return mmAccessToken
}

// Expect sets up expected params for AuthService.AccessToken
func (mmAccessToken *mAuthServiceMockAccessToken) Expect(ctx context.Context, refreshToken string) *mAuthServiceMockAccessToken {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("AuthServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &AuthServiceMockAccessTokenExpectation{}
	}

	if mmAccessToken.defaultExpectation.paramPtrs != nil {
		mmAccessToken.mock.t.Fatalf("AuthServiceMock.AccessToken mock is already set by ExpectParams functions")
	}

	mmAccessToken.defaultExpectation.params = &AuthServiceMockAccessTokenParams{ctx, refreshToken}
	mmAccessToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAccessToken.expectations {
		if minimock.Equal(e.params, mmAccessToken.defaultExpectation.params) {
			mmAccessToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAccessToken.defaultExpectation.params)
		}
	}

	return mmAccessToken
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.AccessToken
func (mmAccessToken *mAuthServiceMockAccessToken) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockAccessToken {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("AuthServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &AuthServiceMockAccessTokenExpectation{}
	}

	if mmAccessToken.defaultExpectation.params != nil {
		mmAccessToken.mock.t.Fatalf("AuthServiceMock.AccessToken mock is already set by Expect")
	}

	if mmAccessToken.defaultExpectation.paramPtrs == nil {
		mmAccessToken.defaultExpectation.paramPtrs = &AuthServiceMockAccessTokenParamPtrs{}
	}
	mmAccessToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmAccessToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAccessToken
}

// ExpectRefreshTokenParam2 sets up expected param refreshToken for AuthService.AccessToken
func (mmAccessToken *mAuthServiceMockAccessToken) ExpectRefreshTokenParam2(refreshToken string) *mAuthServiceMockAccessToken {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("AuthServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &AuthServiceMockAccessTokenExpectation{}
	}

	if mmAccessToken.defaultExpectation.params != nil {
		mmAccessToken.mock.t.Fatalf("AuthServiceMock.AccessToken mock is already set by Expect")
	}

	if mmAccessToken.defaultExpectation.paramPtrs == nil {
		mmAccessToken.defaultExpectation.paramPtrs = &AuthServiceMockAccessTokenParamPtrs{}
	}
	mmAccessToken.defaultExpectation.paramPtrs.refreshToken = &refreshToken
	mmAccessToken.defaultExpectation.expectationOrigins.originRefreshToken = minimock.CallerInfo(1)

	return mmAccessToken
}

// Inspect accepts an inspector function that has same arguments as the AuthService.AccessToken
func (mmAccessToken *mAuthServiceMockAccessToken) Inspect(f func(ctx context.Context, refreshToken string)) *mAuthServiceMockAccessToken {
	if mmAccessToken.mock.inspectFuncAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.AccessToken")
	}

	mmAccessToken.mock.inspectFuncAccessToken = f

	return mmAccessToken
}

// Return sets up results that will be returned by AuthService.AccessToken
func (mmAccessToken *mAuthServiceMockAccessToken) Return(accessToken string, err error) *AuthServiceMock {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("AuthServiceMock.AccessToken mock is already set by Set")
	}

	if mmAccessToken.defaultExpectation == nil {
		mmAccessToken.defaultExpectation = &AuthServiceMockAccessTokenExpectation{mock: mmAccessToken.mock}
	}
	mmAccessToken.defaultExpectation.results = &AuthServiceMockAccessTokenResults{accessToken, err}
	mmAccessToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAccessToken.mock
}

// Set uses given function f to mock the AuthService.AccessToken method
func (mmAccessToken *mAuthServiceMockAccessToken) Set(f func(ctx context.Context, refreshToken string) (accessToken string, err error)) *AuthServiceMock {
	if mmAccessToken.defaultExpectation != nil {
		mmAccessToken.mock.t.Fatalf("Default expectation is already set for the AuthService.AccessToken method")
	}

	if len(mmAccessToken.expectations) > 0 {
		mmAccessToken.mock.t.Fatalf("Some expectations are already set for the AuthService.AccessToken method")
	}

	mmAccessToken.mock.funcAccessToken = f
	mmAccessToken.mock.funcAccessTokenOrigin = minimock.CallerInfo(1)
	return mmAccessToken.mock
}

// When sets expectation for the AuthService.AccessToken which will trigger the result defined by the following
// Then helper
func (mmAccessToken *mAuthServiceMockAccessToken) When(ctx context.Context, refreshToken string) *AuthServiceMockAccessTokenExpectation {
	if mmAccessToken.mock.funcAccessToken != nil {
		mmAccessToken.mock.t.Fatalf("AuthServiceMock.AccessToken mock is already set by Set")
	}

	expectation := &AuthServiceMockAccessTokenExpectation{
		mock:               mmAccessToken.mock,
		params:             &AuthServiceMockAccessTokenParams{ctx, refreshToken},
		expectationOrigins: AuthServiceMockAccessTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAccessToken.expectations = append(mmAccessToken.expectations, expectation)
	return expectation
}

// Then sets up AuthService.AccessToken return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockAccessTokenExpectation) Then(accessToken string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockAccessTokenResults{accessToken, err}
	return e.mock
}

// Times sets number of times AuthService.AccessToken should be invoked
func (mmAccessToken *mAuthServiceMockAccessToken) Times(n uint64) *mAuthServiceMockAccessToken {
	if n == 0 {
		mmAccessToken.mock.t.Fatalf("Times of AuthServiceMock.AccessToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAccessToken.expectedInvocations, n)
	mmAccessToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAccessToken
}

func (mmAccessToken *mAuthServiceMockAccessToken) invocationsDone() bool {
	if len(mmAccessToken.expectations) == 0 && mmAccessToken.defaultExpectation == nil && mmAccessToken.mock.funcAccessToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAccessToken.mock.afterAccessTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAccessToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AccessToken implements mm_auth.AuthService
func (mmAccessToken *AuthServiceMock) AccessToken(ctx context.Context, refreshToken string) (accessToken string, err error) {
	mm_atomic.AddUint64(&mmAccessToken.beforeAccessTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmAccessToken.afterAccessTokenCounter, 1)

	mmAccessToken.t.Helper()

	if mmAccessToken.inspectFuncAccessToken != nil {
		mmAccessToken.inspectFuncAccessToken(ctx, refreshToken)
	}

	mm_params := AuthServiceMockAccessTokenParams{ctx, refreshToken}

	// Record call args
	mmAccessToken.AccessTokenMock.mutex.Lock()
	mmAccessToken.AccessTokenMock.callArgs = append(mmAccessToken.AccessTokenMock.callArgs, &mm_params)
	mmAccessToken.AccessTokenMock.mutex.Unlock()

	for _, e := range mmAccessToken.AccessTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.accessToken, e.results.err
		}
	}

	if mmAccessToken.AccessTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAccessToken.AccessTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmAccessToken.AccessTokenMock.defaultExpectation.params
		mm_want_ptrs := mmAccessToken.AccessTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockAccessTokenParams{ctx, refreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAccessToken.t.Errorf("AuthServiceMock.AccessToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAccessToken.AccessTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.refreshToken != nil && !minimock.Equal(*mm_want_ptrs.refreshToken, mm_got.refreshToken) {
				mmAccessToken.t.Errorf("AuthServiceMock.AccessToken got unexpected parameter refreshToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAccessToken.AccessTokenMock.defaultExpectation.expectationOrigins.originRefreshToken, *mm_want_ptrs.refreshToken, mm_got.refreshToken, minimock.Diff(*mm_want_ptrs.refreshToken, mm_got.refreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAccessToken.t.Errorf("AuthServiceMock.AccessToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAccessToken.AccessTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAccessToken.AccessTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmAccessToken.t.Fatal("No results are set for the AuthServiceMock.AccessToken")
		}
		return (*mm_results).accessToken, (*mm_results).err
	}
	if mmAccessToken.funcAccessToken != nil {
		return mmAccessToken.funcAccessToken(ctx, refreshToken)
	}
	mmAccessToken.t.Fatalf("Unexpected call to AuthServiceMock.AccessToken. %v %v", ctx, refreshToken)
	return
}

// AccessTokenAfterCounter returns a count of finished AuthServiceMock.AccessToken invocations
func (mmAccessToken *AuthServiceMock) AccessTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessToken.afterAccessTokenCounter)
}

// AccessTokenBeforeCounter returns a count of AuthServiceMock.AccessToken invocations
func (mmAccessToken *AuthServiceMock) AccessTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAccessToken.beforeAccessTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.AccessToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAccessToken *mAuthServiceMockAccessToken) Calls() []*AuthServiceMockAccessTokenParams {
	mmAccessToken.mutex.RLock()

	argCopy := make([]*AuthServiceMockAccessTokenParams, len(mmAccessToken.callArgs))
	copy(argCopy, mmAccessToken.callArgs)

	mmAccessToken.mutex.RUnlock()

	return argCopy
}

// MinimockAccessTokenDone returns true if the count of the AccessToken invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockAccessTokenDone() bool {
	if m.AccessTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AccessTokenMock.invocationsDone()
}

// MinimockAccessTokenInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockAccessTokenInspect() {
	for _, e := range m.AccessTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.AccessToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAccessTokenCounter := mm_atomic.LoadUint64(&m.afterAccessTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AccessTokenMock.defaultExpectation != nil && afterAccessTokenCounter < 1 {
		if m.AccessTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.AccessToken at\n%s", m.AccessTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.AccessToken at\n%s with params: %#v", m.AccessTokenMock.defaultExpectation.expectationOrigins.origin, *m.AccessTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAccessToken != nil && afterAccessTokenCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.AccessToken at\n%s", m.funcAccessTokenOrigin)
	}

	if !m.AccessTokenMock.invocationsDone() && afterAccessTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.AccessToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AccessTokenMock.expectedInvocations), m.AccessTokenMock.expectedInvocationsOrigin, afterAccessTokenCounter)
	}
}

type mAuthServiceMockLogin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockLoginExpectation
	expectations       []*AuthServiceMockLoginExpectation

	callArgs []*AuthServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockLoginExpectation specifies expectation struct of the AuthService.Login
type AuthServiceMockLoginExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockLoginParams
	paramPtrs          *AuthServiceMockLoginParamPtrs
	expectationOrigins AuthServiceMockLoginExpectationOrigins
	results            *AuthServiceMockLoginResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockLoginParams contains parameters of the AuthService.Login
type AuthServiceMockLoginParams struct {
	ctx      context.Context
	email    string
	password string
}

// AuthServiceMockLoginParamPtrs contains pointers to parameters of the AuthService.Login
type AuthServiceMockLoginParamPtrs struct {
	ctx      *context.Context
	email    *string
	password *string
}

// AuthServiceMockLoginResults contains results of the AuthService.Login
type AuthServiceMockLoginResults struct {
	refreshToken string
	userId       int64
	err          error
}

// AuthServiceMockLoginOrigins contains origins of expectations of the AuthService.Login
type AuthServiceMockLoginExpectationOrigins struct {
	origin         string
	originCtx      string
	originEmail    string
	originPassword string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mAuthServiceMockLogin) Optional() *mAuthServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Expect(ctx context.Context, email string, password string) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &AuthServiceMockLoginParams{ctx, email, password}
	mmLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectEmailParam2 sets up expected param email for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectEmailParam2(email string) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.email = &email
	mmLogin.defaultExpectation.expectationOrigins.originEmail = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectPasswordParam3 sets up expected param password for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectPasswordParam3(password string) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.password = &password
	mmLogin.defaultExpectation.expectationOrigins.originPassword = minimock.CallerInfo(1)

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Inspect(f func(ctx context.Context, email string, password string)) *mAuthServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Return(refreshToken string, userId int64, err error) *AuthServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &AuthServiceMockLoginResults{refreshToken, userId, err}
	mmLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Set uses given function f to mock the AuthService.Login method
func (mmLogin *mAuthServiceMockLogin) Set(f func(ctx context.Context, email string, password string) (refreshToken string, userId int64, err error)) *AuthServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the AuthService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the AuthService.Login method")
	}

	mmLogin.mock.funcLogin = f
	mmLogin.mock.funcLoginOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// When sets expectation for the AuthService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mAuthServiceMockLogin) When(ctx context.Context, email string, password string) *AuthServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	expectation := &AuthServiceMockLoginExpectation{
		mock:               mmLogin.mock,
		params:             &AuthServiceMockLoginParams{ctx, email, password},
		expectationOrigins: AuthServiceMockLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Login return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockLoginExpectation) Then(refreshToken string, userId int64, err error) *AuthServiceMock {
	e.results = &AuthServiceMockLoginResults{refreshToken, userId, err}
	return e.mock
}

// Times sets number of times AuthService.Login should be invoked
func (mmLogin *mAuthServiceMockLogin) Times(n uint64) *mAuthServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of AuthServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	mmLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogin
}

func (mmLogin *mAuthServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements mm_auth.AuthService
func (mmLogin *AuthServiceMock) Login(ctx context.Context, email string, password string) (refreshToken string, userId int64, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	mmLogin.t.Helper()

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, email, password)
	}

	mm_params := AuthServiceMockLoginParams{ctx, email, password}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.refreshToken, e.results.userId, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockLoginParams{ctx, email, password}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.email != nil && !minimock.Equal(*mm_want_ptrs.email, mm_got.email) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter email, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originEmail, *mm_want_ptrs.email, mm_got.email, minimock.Diff(*mm_want_ptrs.email, mm_got.email))
			}

			if mm_want_ptrs.password != nil && !minimock.Equal(*mm_want_ptrs.password, mm_got.password) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter password, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originPassword, *mm_want_ptrs.password, mm_got.password, minimock.Diff(*mm_want_ptrs.password, mm_got.password))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogin.LoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the AuthServiceMock.Login")
		}
		return (*mm_results).refreshToken, (*mm_results).userId, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, email, password)
	}
	mmLogin.t.Fatalf("Unexpected call to AuthServiceMock.Login. %v %v %v", ctx, email, password)
	return
}

// LoginAfterCounter returns a count of finished AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mAuthServiceMockLogin) Calls() []*AuthServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*AuthServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s", m.LoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s with params: %#v", m.LoginMock.defaultExpectation.expectationOrigins.origin, *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s", m.funcLoginOrigin)
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Login at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), m.LoginMock.expectedInvocationsOrigin, afterLoginCounter)
	}
}

type mAuthServiceMockRefreshToken struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockRefreshTokenExpectation
	expectations       []*AuthServiceMockRefreshTokenExpectation

	callArgs []*AuthServiceMockRefreshTokenParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockRefreshTokenExpectation specifies expectation struct of the AuthService.RefreshToken
type AuthServiceMockRefreshTokenExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockRefreshTokenParams
	paramPtrs          *AuthServiceMockRefreshTokenParamPtrs
	expectationOrigins AuthServiceMockRefreshTokenExpectationOrigins
	results            *AuthServiceMockRefreshTokenResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockRefreshTokenParams contains parameters of the AuthService.RefreshToken
type AuthServiceMockRefreshTokenParams struct {
	ctx             context.Context
	oldRefreshToken string
}

// AuthServiceMockRefreshTokenParamPtrs contains pointers to parameters of the AuthService.RefreshToken
type AuthServiceMockRefreshTokenParamPtrs struct {
	ctx             *context.Context
	oldRefreshToken *string
}

// AuthServiceMockRefreshTokenResults contains results of the AuthService.RefreshToken
type AuthServiceMockRefreshTokenResults struct {
	refreshToken string
	err          error
}

// AuthServiceMockRefreshTokenOrigins contains origins of expectations of the AuthService.RefreshToken
type AuthServiceMockRefreshTokenExpectationOrigins struct {
	origin                string
	originCtx             string
	originOldRefreshToken string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRefreshToken *mAuthServiceMockRefreshToken) Optional() *mAuthServiceMockRefreshToken {
	mmRefreshToken.optional = true
	return mmRefreshToken
}

// Expect sets up expected params for AuthService.RefreshToken
func (mmRefreshToken *mAuthServiceMockRefreshToken) Expect(ctx context.Context, oldRefreshToken string) *mAuthServiceMockRefreshToken {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("AuthServiceMock.RefreshToken mock is already set by Set")
	}

	if mmRefreshToken.defaultExpectation == nil {
		mmRefreshToken.defaultExpectation = &AuthServiceMockRefreshTokenExpectation{}
	}

	if mmRefreshToken.defaultExpectation.paramPtrs != nil {
		mmRefreshToken.mock.t.Fatalf("AuthServiceMock.RefreshToken mock is already set by ExpectParams functions")
	}

	mmRefreshToken.defaultExpectation.params = &AuthServiceMockRefreshTokenParams{ctx, oldRefreshToken}
	mmRefreshToken.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRefreshToken.expectations {
		if minimock.Equal(e.params, mmRefreshToken.defaultExpectation.params) {
			mmRefreshToken.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRefreshToken.defaultExpectation.params)
		}
	}

	return mmRefreshToken
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.RefreshToken
func (mmRefreshToken *mAuthServiceMockRefreshToken) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockRefreshToken {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("AuthServiceMock.RefreshToken mock is already set by Set")
	}

	if mmRefreshToken.defaultExpectation == nil {
		mmRefreshToken.defaultExpectation = &AuthServiceMockRefreshTokenExpectation{}
	}

	if mmRefreshToken.defaultExpectation.params != nil {
		mmRefreshToken.mock.t.Fatalf("AuthServiceMock.RefreshToken mock is already set by Expect")
	}

	if mmRefreshToken.defaultExpectation.paramPtrs == nil {
		mmRefreshToken.defaultExpectation.paramPtrs = &AuthServiceMockRefreshTokenParamPtrs{}
	}
	mmRefreshToken.defaultExpectation.paramPtrs.ctx = &ctx
	mmRefreshToken.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRefreshToken
}

// ExpectOldRefreshTokenParam2 sets up expected param oldRefreshToken for AuthService.RefreshToken
func (mmRefreshToken *mAuthServiceMockRefreshToken) ExpectOldRefreshTokenParam2(oldRefreshToken string) *mAuthServiceMockRefreshToken {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("AuthServiceMock.RefreshToken mock is already set by Set")
	}

	if mmRefreshToken.defaultExpectation == nil {
		mmRefreshToken.defaultExpectation = &AuthServiceMockRefreshTokenExpectation{}
	}

	if mmRefreshToken.defaultExpectation.params != nil {
		mmRefreshToken.mock.t.Fatalf("AuthServiceMock.RefreshToken mock is already set by Expect")
	}

	if mmRefreshToken.defaultExpectation.paramPtrs == nil {
		mmRefreshToken.defaultExpectation.paramPtrs = &AuthServiceMockRefreshTokenParamPtrs{}
	}
	mmRefreshToken.defaultExpectation.paramPtrs.oldRefreshToken = &oldRefreshToken
	mmRefreshToken.defaultExpectation.expectationOrigins.originOldRefreshToken = minimock.CallerInfo(1)

	return mmRefreshToken
}

// Inspect accepts an inspector function that has same arguments as the AuthService.RefreshToken
func (mmRefreshToken *mAuthServiceMockRefreshToken) Inspect(f func(ctx context.Context, oldRefreshToken string)) *mAuthServiceMockRefreshToken {
	if mmRefreshToken.mock.inspectFuncRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.RefreshToken")
	}

	mmRefreshToken.mock.inspectFuncRefreshToken = f

	return mmRefreshToken
}

// Return sets up results that will be returned by AuthService.RefreshToken
func (mmRefreshToken *mAuthServiceMockRefreshToken) Return(refreshToken string, err error) *AuthServiceMock {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("AuthServiceMock.RefreshToken mock is already set by Set")
	}

	if mmRefreshToken.defaultExpectation == nil {
		mmRefreshToken.defaultExpectation = &AuthServiceMockRefreshTokenExpectation{mock: mmRefreshToken.mock}
	}
	mmRefreshToken.defaultExpectation.results = &AuthServiceMockRefreshTokenResults{refreshToken, err}
	mmRefreshToken.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRefreshToken.mock
}

// Set uses given function f to mock the AuthService.RefreshToken method
func (mmRefreshToken *mAuthServiceMockRefreshToken) Set(f func(ctx context.Context, oldRefreshToken string) (refreshToken string, err error)) *AuthServiceMock {
	if mmRefreshToken.defaultExpectation != nil {
		mmRefreshToken.mock.t.Fatalf("Default expectation is already set for the AuthService.RefreshToken method")
	}

	if len(mmRefreshToken.expectations) > 0 {
		mmRefreshToken.mock.t.Fatalf("Some expectations are already set for the AuthService.RefreshToken method")
	}

	mmRefreshToken.mock.funcRefreshToken = f
	mmRefreshToken.mock.funcRefreshTokenOrigin = minimock.CallerInfo(1)
	return mmRefreshToken.mock
}

// When sets expectation for the AuthService.RefreshToken which will trigger the result defined by the following
// Then helper
func (mmRefreshToken *mAuthServiceMockRefreshToken) When(ctx context.Context, oldRefreshToken string) *AuthServiceMockRefreshTokenExpectation {
	if mmRefreshToken.mock.funcRefreshToken != nil {
		mmRefreshToken.mock.t.Fatalf("AuthServiceMock.RefreshToken mock is already set by Set")
	}

	expectation := &AuthServiceMockRefreshTokenExpectation{
		mock:               mmRefreshToken.mock,
		params:             &AuthServiceMockRefreshTokenParams{ctx, oldRefreshToken},
		expectationOrigins: AuthServiceMockRefreshTokenExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRefreshToken.expectations = append(mmRefreshToken.expectations, expectation)
	return expectation
}

// Then sets up AuthService.RefreshToken return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockRefreshTokenExpectation) Then(refreshToken string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockRefreshTokenResults{refreshToken, err}
	return e.mock
}

// Times sets number of times AuthService.RefreshToken should be invoked
func (mmRefreshToken *mAuthServiceMockRefreshToken) Times(n uint64) *mAuthServiceMockRefreshToken {
	if n == 0 {
		mmRefreshToken.mock.t.Fatalf("Times of AuthServiceMock.RefreshToken mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRefreshToken.expectedInvocations, n)
	mmRefreshToken.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRefreshToken
}

func (mmRefreshToken *mAuthServiceMockRefreshToken) invocationsDone() bool {
	if len(mmRefreshToken.expectations) == 0 && mmRefreshToken.defaultExpectation == nil && mmRefreshToken.mock.funcRefreshToken == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRefreshToken.mock.afterRefreshTokenCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRefreshToken.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RefreshToken implements mm_auth.AuthService
func (mmRefreshToken *AuthServiceMock) RefreshToken(ctx context.Context, oldRefreshToken string) (refreshToken string, err error) {
	mm_atomic.AddUint64(&mmRefreshToken.beforeRefreshTokenCounter, 1)
	defer mm_atomic.AddUint64(&mmRefreshToken.afterRefreshTokenCounter, 1)

	mmRefreshToken.t.Helper()

	if mmRefreshToken.inspectFuncRefreshToken != nil {
		mmRefreshToken.inspectFuncRefreshToken(ctx, oldRefreshToken)
	}

	mm_params := AuthServiceMockRefreshTokenParams{ctx, oldRefreshToken}

	// Record call args
	mmRefreshToken.RefreshTokenMock.mutex.Lock()
	mmRefreshToken.RefreshTokenMock.callArgs = append(mmRefreshToken.RefreshTokenMock.callArgs, &mm_params)
	mmRefreshToken.RefreshTokenMock.mutex.Unlock()

	for _, e := range mmRefreshToken.RefreshTokenMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.refreshToken, e.results.err
		}
	}

	if mmRefreshToken.RefreshTokenMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRefreshToken.RefreshTokenMock.defaultExpectation.Counter, 1)
		mm_want := mmRefreshToken.RefreshTokenMock.defaultExpectation.params
		mm_want_ptrs := mmRefreshToken.RefreshTokenMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockRefreshTokenParams{ctx, oldRefreshToken}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRefreshToken.t.Errorf("AuthServiceMock.RefreshToken got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshToken.RefreshTokenMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.oldRefreshToken != nil && !minimock.Equal(*mm_want_ptrs.oldRefreshToken, mm_got.oldRefreshToken) {
				mmRefreshToken.t.Errorf("AuthServiceMock.RefreshToken got unexpected parameter oldRefreshToken, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRefreshToken.RefreshTokenMock.defaultExpectation.expectationOrigins.originOldRefreshToken, *mm_want_ptrs.oldRefreshToken, mm_got.oldRefreshToken, minimock.Diff(*mm_want_ptrs.oldRefreshToken, mm_got.oldRefreshToken))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRefreshToken.t.Errorf("AuthServiceMock.RefreshToken got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRefreshToken.RefreshTokenMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRefreshToken.RefreshTokenMock.defaultExpectation.results
		if mm_results == nil {
			mmRefreshToken.t.Fatal("No results are set for the AuthServiceMock.RefreshToken")
		}
		return (*mm_results).refreshToken, (*mm_results).err
	}
	if mmRefreshToken.funcRefreshToken != nil {
		return mmRefreshToken.funcRefreshToken(ctx, oldRefreshToken)
	}
	mmRefreshToken.t.Fatalf("Unexpected call to AuthServiceMock.RefreshToken. %v %v", ctx, oldRefreshToken)
	return
}

// RefreshTokenAfterCounter returns a count of finished AuthServiceMock.RefreshToken invocations
func (mmRefreshToken *AuthServiceMock) RefreshTokenAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshToken.afterRefreshTokenCounter)
}

// RefreshTokenBeforeCounter returns a count of AuthServiceMock.RefreshToken invocations
func (mmRefreshToken *AuthServiceMock) RefreshTokenBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRefreshToken.beforeRefreshTokenCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.RefreshToken.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRefreshToken *mAuthServiceMockRefreshToken) Calls() []*AuthServiceMockRefreshTokenParams {
	mmRefreshToken.mutex.RLock()

	argCopy := make([]*AuthServiceMockRefreshTokenParams, len(mmRefreshToken.callArgs))
	copy(argCopy, mmRefreshToken.callArgs)

	mmRefreshToken.mutex.RUnlock()

	return argCopy
}

// MinimockRefreshTokenDone returns true if the count of the RefreshToken invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockRefreshTokenDone() bool {
	if m.RefreshTokenMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RefreshTokenMock.invocationsDone()
}

// MinimockRefreshTokenInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockRefreshTokenInspect() {
	for _, e := range m.RefreshTokenMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.RefreshToken at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRefreshTokenCounter := mm_atomic.LoadUint64(&m.afterRefreshTokenCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RefreshTokenMock.defaultExpectation != nil && afterRefreshTokenCounter < 1 {
		if m.RefreshTokenMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.RefreshToken at\n%s", m.RefreshTokenMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.RefreshToken at\n%s with params: %#v", m.RefreshTokenMock.defaultExpectation.expectationOrigins.origin, *m.RefreshTokenMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRefreshToken != nil && afterRefreshTokenCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.RefreshToken at\n%s", m.funcRefreshTokenOrigin)
	}

	if !m.RefreshTokenMock.invocationsDone() && afterRefreshTokenCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.RefreshToken at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RefreshTokenMock.expectedInvocations), m.RefreshTokenMock.expectedInvocationsOrigin, afterRefreshTokenCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAccessTokenInspect()

			m.MinimockLoginInspect()

			m.MinimockRefreshTokenInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAccessTokenDone() &&
		m.MinimockLoginDone() &&
		m.MinimockRefreshTokenDone()
}
